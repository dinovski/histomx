cat(">>Housekeeping gene(s) with expression below negative control probes detected.")
}
## POS_E counts should be > lod
## % genes above LoD
endoCounts <- countTable[countTable$CodeClass=="Endogenous",c("Name", sampID)]
colnames(endoCounts) <- c("gene", "counts")
attTable$'POS_E counts' <- pos_e_counts
attTable$ncgMean <- ncgMean
attTable$ncgSD <- ncgSD
attTable$LoD <- lod
attTable$'% ENDO genes above LoD' <- round(length(endoCounts[which(endoCounts$counts > lod),"gene"]) / nrow(endoCounts) * 100, 2)
## signal versus noise: S/N = ratio of geometric mean of HK / LoD
attTable$'SNratio' = attTable$'geo mean HK genes' / attTable$LoD
## positive control linearity
pos <- countTable[countTable$CodeClass=="Positive",c("Name", sampID)]
pos <- pos[grep("POS_F", pos$Name, invert=TRUE),] ## POS_F should be < limit of detection
colnames(pos) <- c("Name", "Count")
if (!all(grepl("[[:digit:]]", pos$Name))) {
stop("Positive controls must have parenthesized concentrations: ex POS_A(128)")
}
pos$Conc <- as.numeric(gsub(".*\\((.*)\\).*", "\\1", pos$Name))
pcl <- round(summary(lm(pos$Count ~ pos$Conc))$r.squared, 4)
attTable$'PCL' <- pcl
plot_pos_linearity <- ggplot(pos, aes(x=Conc, y=Count)) + ggtitle(paste(expression(R^2), " = ", pcl)) +
geom_point(shape = 21, colour="darkblue", size=3, fill = "dodgerblue") +
xlab("concentration") + ylab("raw counts") +
geom_text_repel(data=pos, aes(x=Conc, y=Count, label=Name), size=4, colour="darkgray") +
geom_smooth(method = "lm", fullrange=TRUE, se=TRUE, linewidth=1,
color="slategray", formula = y ~ x, linetype="dashed")
if (saveFiles==TRUE) {
ggsave(paste0(outPath, sampID, "/pcl_plot_", sampID, "_", Sys.Date(), ".pdf"), plot=plot_pos_linearity, device="pdf", width=7, height=7)
}
outTable <- attTable[!colnames(attTable) %in% c("Owner", "Comments", "SystemAPF", "laneID", "ScannerID", "StagePosition", "CartridgeBarcode", "CartridgeID")]
outTable <- outTable[,c("FileVersion", "SoftwareVersion", "Date", "GeneRLF",
"BindingDensity", "FovCount", "FovCounted", "% registered FOVs",
"geo mean POS genes", "geo mean NEG genes", "geo mean HK genes", "geo mean ENDO genes",
"POS_E counts", "ncgMean", "ncgSD", "LoD", "% ENDO genes above LoD",
"PCL", "SNratio")]
vars_to_round <- c("BindingDensity", "FovCount", "FovCounted", "% registered FOVs",
"geo mean POS genes", "geo mean NEG genes", "geo mean HK genes", "geo mean ENDO genes",
"POS_E counts", "ncgMean", "ncgSD", "LoD", "% ENDO genes above LoD",
"PCL", "SNratio")
## round all numeric values to 2 decimal points
outTable[vars_to_round] <- format(round(outTable[vars_to_round], 2), nsmall = 2)
outTable <- data.frame(t(outTable), check.names=FALSE, stringsAsFactors=FALSE)
if (saveFiles==TRUE) {
write.table(outTable, file=paste0(outPath, sampID, "/run_attribute_table_", sampID, "_", Sys.Date(), ".txt"),
quote=FALSE, sep='\t', row.names=TRUE)
}
##-------------------------------------------
## output files and plots for markdown report
return(list(qc_table=outTable,
pl_plot=plot_pos_linearity))
}
newRCC <- list.files(inPath, pattern=".RCC", full.names=TRUE, recursive=FALSE)
newRCC
##-----------------------------------
## Generate predictions for new data
length(newRCC)
lapply(newRCC, rccQC, outPath=outPath)
lapply(newRCC, rccQC, outPath=outPath, saveFiles=TRUE)
##-----------------------------------
## combine all attribute files
attFiles <- list.files(outPath, pattern="run_attribute_table", full.names=TRUE, recursive=TRUE)
attFiles
att.all <- lapply(attFiles, function(file) {
tab <- read.table(file, sep='\t')
tab$var <- rownames(tab)
return(tab)
})
attTable <- Reduce(function(x,y) merge(x, y, all=FALSE), att.all)
rownames(attTable) <- attTable$var
attTable$var <- NULL
new.ms <- data.frame(t(attTable), check.names=F)
new.ms$ID <- rownames(new.ms)
new.ms
head(new.ms)
att.all <- lapply(attFiles, function(file) {
tab <- read.table(file, sep='\t', check.names=FALSE)
tab$var <- rownames(tab)
return(tab)
})
attTable <- Reduce(function(x,y) merge(x, y, all=FALSE), att.all)
rownames(attTable) <- attTable$var
attTable$var <- NULL
new.ms <- data.frame(t(attTable), check.names=F)
new.ms$ID <- rownames(new.ms)
head(new.ms)
hk_exp < attTable$'geo mean NEG genes')
hk_exp < attTable$'geo mean NEG genes'
length(hk_exp < attTable$'geo mean NEG genes'
hk_exp
attTable$'geo mean NEG genes'
## import + parse RCC file
ns.data <- parseRCC(RCCfile)
## extract raw counts
countTable <- ns.data$counts
rownames(countTable) <- countTable$Name
## extract attribute table
attTable <- ns.data$attributes
rownames(attTable) <- attTable$variable
attTable$variable <- NULL
attTable <- data.frame(t(attTable), check.names=FALSE)
sampID <- attTable$sampID
newOut <- paste0(outPath, sampID, "/")
dir.create(newOut, recursive=TRUE, showWarnings=FALSE)
numeric_vars <- c("FileVersion", "laneID", "BindingDensity", "FovCount", "FovCounted")
attTable[,numeric_vars] <- sapply(attTable[,numeric_vars], as.numeric)
## recommended threshold: >75%
attTable$'% registered FOVs' <- round(attTable$FovCounted/attTable$FovCount*100, 2)
## geometric means
attTable$'geo mean POS genes' <- exp(mean(log(countTable[countTable$CodeClass=="Positive",sampID]+1)))
attTable$'geo mean NEG genes' <- exp(mean(log(countTable[countTable$CodeClass=="Negative",sampID]+1)))
attTable$'geo mean ENDO genes' <- exp(mean(log(countTable[countTable$CodeClass=="Endogenous",sampID]+1)))
attTable$'geo mean HK genes' <- exp(mean(log(countTable[countTable$CodeClass=="Housekeeping",sampID]+1)))
## neg/pos control gene QC
## POS_E counts should be > 2 sd * mean(NEG)
pos_e = countTable[grep("POS_E", countTable$Name),]
ncg <- countTable[countTable$CodeClass=="Negative",]
ncgMean = mean(ncg[,sampID])
ncgSD = sd(ncg[,sampID])
lod = ncgMean + 2*ncgSD
llod = ncgMean - 2*ncgSD
pos_e_counts = pos_e[,-c(1:3)]
## Check if any HK genes below LoD
hk_exp <- countTable[countTable$CodeClass=="Housekeeping",4]
ncgMean
lod
attTable$'geo mean NEG genes')
attTable$'geo mean NEG genes'
attTable$'geo mean NEG genes'
lod
any(hk_exp < lod)
length(any(hk_exp < lod))
hk_exp
hk_exp[]4
hk_exp[4]
hk_exp[4]<-2
any(hk_exp < lod)
length(hk_exp < lod)
which(hk_exp < lod)
hk_exp[7]
hk_exp[8]<-2
which(hk_exp < lod))
which(hk_exp < lod)
length(which(hk_exp < lod))
## Check if any HK genes below geoMean(ncg)
hk_exp <- countTable[countTable$CodeClass=="Housekeeping",4]
if (any(hk_exp < lod)) {
attTable$'HK below Lod' <- length(which(hk_exp < lod))
cat(">>Housekeeping gene(s) with expression below limit of detection detected.")
} else {
attTable$'HK below Lod' <- 0
}
attTable
any(hk_exp < lod)
hk_exp
hk_exp[4]<-2
if (any(hk_exp < lod)) {
attTable$'HK below Lod' <- length(which(hk_exp < lod))
cat(">>Housekeeping gene(s) with expression below limit of detection detected.")
} else {
attTable$'HK below Lod' <- 0
}
attTable
lod
llod
ncgMean
attTable$'geo mean NEG genes'
##------------------
## QC a single RCC file
## if saveFiles=TRUE, the PCL plot and attribute table will be saved to the outPath
rccQC <- function(RCCfile, outPath, saveFiles=FALSE) {
if (rlang::is_empty(outPath)) {
cat("Output path:", outPath, "\n")
outPath=dirname(RCCfile)
} else {
cat("Output path:", outPath, "\n")
outPath=outPath
}
## import + parse RCC file
ns.data <- parseRCC(RCCfile)
## extract raw counts
countTable <- ns.data$counts
rownames(countTable) <- countTable$Name
## extract attribute table
attTable <- ns.data$attributes
rownames(attTable) <- attTable$variable
attTable$variable <- NULL
attTable <- data.frame(t(attTable), check.names=FALSE)
sampID <- attTable$sampID
newOut <- paste0(outPath, sampID, "/")
dir.create(newOut, recursive=TRUE, showWarnings=FALSE)
numeric_vars <- c("FileVersion", "laneID", "BindingDensity", "FovCount", "FovCounted")
attTable[,numeric_vars] <- sapply(attTable[,numeric_vars], as.numeric)
## recommended threshold: >75%
attTable$'% registered FOVs' <- round(attTable$FovCounted/attTable$FovCount*100, 2)
## geometric means
attTable$'geo mean POS genes' <- exp(mean(log(countTable[countTable$CodeClass=="Positive",sampID]+1)))
attTable$'geo mean NEG genes' <- exp(mean(log(countTable[countTable$CodeClass=="Negative",sampID]+1)))
attTable$'geo mean ENDO genes' <- exp(mean(log(countTable[countTable$CodeClass=="Endogenous",sampID]+1)))
attTable$'geo mean HK genes' <- exp(mean(log(countTable[countTable$CodeClass=="Housekeeping",sampID]+1)))
## neg/pos control gene QC
## POS_E counts should be > 2 sd * mean(NEG)
pos_e = countTable[grep("POS_E", countTable$Name),]
ncg <- countTable[countTable$CodeClass=="Negative",]
ncgMean = mean(ncg[,sampID])
ncgSD = sd(ncg[,sampID])
lod = ncgMean + 2*ncgSD
llod = ncgMean - 2*ncgSD
pos_e_counts = pos_e[,-c(1:3)]
## Check if any HK genes below geoMean(ncg)
hk_exp <- countTable[countTable$CodeClass=="Housekeeping",4]
if (any(hk_exp < lod)) {
attTable$'HK below Lod' <- length(which(hk_exp < lod))
cat(">>Housekeeping gene(s) with expression below limit of detection detected.")
} else {
attTable$'HK below Lod' <- 0
}
## POS_E counts should be > lod
## % genes above LoD
endoCounts <- countTable[countTable$CodeClass=="Endogenous",c("Name", sampID)]
colnames(endoCounts) <- c("gene", "counts")
attTable$'POS_E counts' <- pos_e_counts
attTable$ncgMean <- ncgMean
attTable$ncgSD <- ncgSD
attTable$LoD <- lod
attTable$'% ENDO genes above LoD' <- round(length(endoCounts[which(endoCounts$counts > lod),"gene"]) / nrow(endoCounts) * 100, 2)
## signal versus noise: S/N = ratio of geometric mean of HK / LoD
attTable$'SNratio' = attTable$'geo mean HK genes' / attTable$LoD
## positive control linearity
pos <- countTable[countTable$CodeClass=="Positive",c("Name", sampID)]
pos <- pos[grep("POS_F", pos$Name, invert=TRUE),] ## POS_F should be < limit of detection
colnames(pos) <- c("Name", "Count")
if (!all(grepl("[[:digit:]]", pos$Name))) {
stop("Positive controls must have parenthesized concentrations: ex POS_A(128)")
}
pos$Conc <- as.numeric(gsub(".*\\((.*)\\).*", "\\1", pos$Name))
pcl <- round(summary(lm(pos$Count ~ pos$Conc))$r.squared, 4)
attTable$'PCL' <- pcl
plot_pos_linearity <- ggplot(pos, aes(x=Conc, y=Count)) + ggtitle(paste(expression(R^2), " = ", pcl)) +
geom_point(shape = 21, colour="darkblue", size=3, fill = "dodgerblue") +
xlab("concentration") + ylab("raw counts") +
geom_text_repel(data=pos, aes(x=Conc, y=Count, label=Name), size=4, colour="darkgray") +
geom_smooth(method = "lm", fullrange=TRUE, se=TRUE, linewidth=1,
color="slategray", formula = y ~ x, linetype="dashed")
if (saveFiles==TRUE) {
ggsave(paste0(outPath, sampID, "/pcl_plot_", sampID, "_", Sys.Date(), ".pdf"), plot=plot_pos_linearity, device="pdf", width=7, height=7)
}
outTable <- attTable[!colnames(attTable) %in% c("Owner", "Comments", "SystemAPF", "laneID", "ScannerID", "StagePosition", "CartridgeBarcode", "CartridgeID")]
outTable <- outTable[,c("FileVersion", "SoftwareVersion", "Date", "GeneRLF",
"BindingDensity", "FovCount", "FovCounted", "% registered FOVs",
"geo mean POS genes", "geo mean NEG genes", "geo mean HK genes", "geo mean ENDO genes",
"POS_E counts", "ncgMean", "ncgSD", "LoD", "% ENDO genes above LoD",
"PCL", "SNratio")]
vars_to_round <- c("BindingDensity", "FovCount", "FovCounted", "% registered FOVs",
"geo mean POS genes", "geo mean NEG genes", "geo mean HK genes", "geo mean ENDO genes",
"POS_E counts", "ncgMean", "ncgSD", "LoD", "% ENDO genes above LoD",
"PCL", "SNratio")
## round all numeric values to 2 decimal points
outTable[vars_to_round] <- format(round(outTable[vars_to_round], 2), nsmall = 2)
outTable <- data.frame(t(outTable), check.names=FALSE, stringsAsFactors=FALSE)
if (saveFiles==TRUE) {
write.table(outTable, file=paste0(outPath, sampID, "/run_attribute_table_", sampID, "_", Sys.Date(), ".txt"),
quote=FALSE, sep='\t', row.names=TRUE)
}
##-------------------------------------------
## output files and plots for markdown report
return(list(qc_table=outTable,
pl_plot=plot_pos_linearity))
}
lapply(newRCC, rccQC, outPath=outPath, saveFiles=TRUE)
##-----------------------------------
## combine all attribute files
attFiles <- list.files(outPath, pattern="run_attribute_table", full.names=TRUE, recursive=TRUE)
att.all <- lapply(attFiles, function(file) {
tab <- read.table(file, sep='\t', check.names=FALSE)
tab$var <- rownames(tab)
return(tab)
})
attTable <- Reduce(function(x,y) merge(x, y, all=FALSE), att.all)
rownames(attTable) <- attTable$var
attTable$var <- NULL
new.ms <- data.frame(t(attTable), check.names=F)
new.ms$ID <- rownames(new.ms)
new.ms
head(new.ms)
tab <- read.csv('~/Dropbox/PTG/transcriptomics/nanostring/kidney/refset/current/model_dev/model_eval/test_scores_all_annot.csv')
new.ms <- merge(tab, new.ms, by="ID", all.x=T)
head(ns.ms)
head(new.ms)
head(new.ms)
nrow(tab)
colnames(tab)
new.att<-new.ms
head(new.att)
# source from histomx
setwd('~/Desktop/histomx/bin/')
source('~/Desktop/histomx/scripts/BHOTpred.R')
##---------------------------------
## import new biopsies
#inPath='~/Dropbox/PTG/transcriptomics/nanostring/kidney/refset/current/RefSet-KTD1-FFPE-locked/'
inPath='~/Desktop/histomx_examples/test_rccs/'
newRCC <- list.files(inPath, pattern=".RCC", full.names=TRUE, recursive=FALSE)
outPath=paste0(inPath, '/histomx_results_sep/')
dir.create(outPath, recursive=TRUE, showWarnings=FALSE)
outPath
##-----------------------------------
## Generate predictions for new data
length(newRCC)
## QC
lapply(newRCC, rccQC, outPath=outPath, saveFiles=TRUE)
##-----------------------------------
## combine all attribute files
attFiles <- list.files(outPath, pattern="run_attribute_table", full.names=TRUE, recursive=TRUE)
att.all <- lapply(attFiles, function(file) {
tab <- read.table(file, sep='\t', check.names=FALSE)
tab$var <- rownames(tab)
return(tab)
})
attTable <- Reduce(function(x,y) merge(x, y, all=FALSE), att.all)
rownames(attTable) <- attTable$var
attTable$var <- NULL
new.att <- data.frame(t(attTable), check.names=F)
new.att$ID <- rownames(new.att)
head(new.att)
##------------------
## QC a single RCC file
## if saveFiles=TRUE, the PCL plot and attribute table will be saved to the outPath
rccQC <- function(RCCfile, outPath, saveFiles=FALSE) {
if (rlang::is_empty(outPath)) {
cat("Output path:", outPath, "\n")
outPath=dirname(RCCfile)
} else {
cat("Output path:", outPath, "\n")
outPath=outPath
}
## import + parse RCC file
ns.data <- parseRCC(RCCfile)
## extract raw counts
countTable <- ns.data$counts
rownames(countTable) <- countTable$Name
## extract attribute table
attTable <- ns.data$attributes
rownames(attTable) <- attTable$variable
attTable$variable <- NULL
attTable <- data.frame(t(attTable), check.names=FALSE)
sampID <- attTable$sampID
newOut <- paste0(outPath, sampID, "/")
dir.create(newOut, recursive=TRUE, showWarnings=FALSE)
numeric_vars <- c("FileVersion", "laneID", "BindingDensity", "FovCount", "FovCounted")
attTable[,numeric_vars] <- sapply(attTable[,numeric_vars], as.numeric)
## recommended threshold: >75%
attTable$'% registered FOVs' <- round(attTable$FovCounted/attTable$FovCount*100, 2)
## geometric means
attTable$'geo mean POS genes' <- exp(mean(log(countTable[countTable$CodeClass=="Positive",sampID]+1)))
attTable$'geo mean NEG genes' <- exp(mean(log(countTable[countTable$CodeClass=="Negative",sampID]+1)))
attTable$'geo mean ENDO genes' <- exp(mean(log(countTable[countTable$CodeClass=="Endogenous",sampID]+1)))
attTable$'geo mean HK genes' <- exp(mean(log(countTable[countTable$CodeClass=="Housekeeping",sampID]+1)))
## neg/pos control gene QC
## POS_E counts should be > 2 sd * mean(NEG)
pos_e = countTable[grep("POS_E", countTable$Name),]
ncg <- countTable[countTable$CodeClass=="Negative",]
ncgMean = mean(ncg[,sampID])
ncgSD = sd(ncg[,sampID])
lod = ncgMean + 2*ncgSD
llod = ncgMean - 2*ncgSD
pos_e_counts = pos_e[,-c(1:3)]
## Check if any HK genes below geoMean(ncg)
hk_exp <- countTable[countTable$CodeClass=="Housekeeping",4]
if (any(hk_exp < lod)) {
attTable$'HK below Lod' <- length(which(hk_exp < lod))
cat(">>Housekeeping gene(s) with expression below limit of detection detected.")
} else {
attTable$'HK below Lod' <- 0
}
## POS_E counts should be > lod
## % genes above LoD
endoCounts <- countTable[countTable$CodeClass=="Endogenous",c("Name", sampID)]
colnames(endoCounts) <- c("gene", "counts")
attTable$'POS_E counts' <- pos_e_counts
attTable$ncgMean <- ncgMean
attTable$ncgSD <- ncgSD
attTable$LoD <- lod
attTable$'% ENDO genes above LoD' <- round(length(endoCounts[which(endoCounts$counts > lod),"gene"]) / nrow(endoCounts) * 100, 2)
## signal versus noise: S/N = ratio of geometric mean of HK / LoD
attTable$'SNratio' = attTable$'geo mean HK genes' / attTable$LoD
## positive control linearity
pos <- countTable[countTable$CodeClass=="Positive",c("Name", sampID)]
pos <- pos[grep("POS_F", pos$Name, invert=TRUE),] ## POS_F should be < limit of detection
colnames(pos) <- c("Name", "Count")
if (!all(grepl("[[:digit:]]", pos$Name))) {
stop("Positive controls must have parenthesized concentrations: ex POS_A(128)")
}
pos$Conc <- as.numeric(gsub(".*\\((.*)\\).*", "\\1", pos$Name))
pcl <- round(summary(lm(pos$Count ~ pos$Conc))$r.squared, 4)
attTable$'PCL' <- pcl
plot_pos_linearity <- ggplot(pos, aes(x=Conc, y=Count)) + ggtitle(paste(expression(R^2), " = ", pcl)) +
geom_point(shape = 21, colour="darkblue", size=3, fill = "dodgerblue") +
xlab("concentration") + ylab("raw counts") +
geom_text_repel(data=pos, aes(x=Conc, y=Count, label=Name), size=4, colour="darkgray") +
geom_smooth(method = "lm", fullrange=TRUE, se=TRUE, linewidth=1,
color="slategray", formula = y ~ x, linetype="dashed")
if (saveFiles==TRUE) {
ggsave(paste0(outPath, sampID, "/pcl_plot_", sampID, "_", Sys.Date(), ".pdf"), plot=plot_pos_linearity, device="pdf", width=7, height=7)
}
outTable <- attTable[!colnames(attTable) %in% c("Owner", "Comments", "SystemAPF", "laneID", "ScannerID", "StagePosition", "CartridgeBarcode", "CartridgeID")]
outTable <- outTable[,c("FileVersion", "SoftwareVersion", "Date", "GeneRLF",
"BindingDensity", "FovCount", "FovCounted", "% registered FOVs",
"geo mean POS genes", "geo mean NEG genes", "geo mean HK genes", "geo mean ENDO genes",
"POS_E counts", "ncgMean", "ncgSD", "LoD", "% ENDO genes above LoD", 'HK below Lod',
"PCL", "SNratio")]
vars_to_round <- c("BindingDensity", "FovCount", "FovCounted", "% registered FOVs",
"geo mean POS genes", "geo mean NEG genes", "geo mean HK genes", "geo mean ENDO genes",
"POS_E counts", "ncgMean", "ncgSD", "LoD", "% ENDO genes above LoD",
"PCL", "SNratio")
## round all numeric values to 2 decimal points
outTable[vars_to_round] <- format(round(outTable[vars_to_round], 2), nsmall = 2)
outTable <- data.frame(t(outTable), check.names=FALSE, stringsAsFactors=FALSE)
if (saveFiles==TRUE) {
write.table(outTable, file=paste0(outPath, sampID, "/run_attribute_table_", sampID, "_", Sys.Date(), ".txt"),
quote=FALSE, sep='\t', row.names=TRUE)
}
##-------------------------------------------
## output files and plots for markdown report
return(list(qc_table=outTable,
pl_plot=plot_pos_linearity))
}
## QC
lapply(newRCC, rccQC, outPath=outPath, saveFiles=TRUE)
##-----------------------------------
## combine all attribute files
attFiles <- list.files(outPath, pattern="run_attribute_table", full.names=TRUE, recursive=TRUE)
att.all <- lapply(attFiles, function(file) {
tab <- read.table(file, sep='\t', check.names=FALSE)
tab$var <- rownames(tab)
return(tab)
})
attTable <- Reduce(function(x,y) merge(x, y, all=FALSE), att.all)
rownames(attTable) <- attTable$var
attTable$var <- NULL
new.att <- data.frame(t(attTable), check.names=F)
new.att$ID <- rownames(new.att)
hist(new.att$`HK below Lod`)
hist(as.numeric(new.att$`HK below Lod`))
table(as.numeric(new.att$`HK below Lod`))
table(as.numeric(new.att$`HK below Lod`))
data.frame(table(as.numeric(new.att$`HK below Lod`)))
df<-data.frame(table(as.numeric(new.att$`HK below Lod`)))
df[df$Var1>0,]
df[which(df$Var1)>0,]
df
df$Freq<-as.numeric(df$Freq)
df
df[df$Var1!="0",]
df[df$Var1!="0","Freq"]
sum(df[df$Var1!="0","Freq"])
53-22
30/127
outPath
scoreFiles <- list.files(outPath, pattern="molecular_score_table", full.names=TRUE, recursive=TRUE)
scores.all <- lapply(scoreFiles, function(file) {
cat(file, "\n")
tab <- read.table(file, header=TRUE, check.names=FALSE)
rownames(tab) <- tab$ID
#colnames(tab)[colnames(tab)=="ID"]<-tab$ID
tab$ID <- NULL
tab <- data.frame(t(tab), check.names=FALSE)
tab$var <- rownames(tab)
tab <- tab[grep("amr|tcmr", tab$var),]
return(tab)
})
scoreTable <- Reduce(function(x,y) merge(x, y, all=FALSE, by="var"), scores.all)
rownames(scoreTable) <- scoreTable$var
scoreTable$var <- NULL
colnames(scoreTable) <- gsub("\\.x", "", colnames(scoreTable))
new.ms <- data.frame(t(scoreTable), check.names=FALSE)
new.ms$ID <- rownames(new.ms)
## add HistoMx scores to annotated validation tables
new.ms <- new.ms[,c("ID", "amr", "tcmr")]
colnames(new.ms) <- c("ID", "AMR_histomx", "TCMR_histomx")
new.ms$AMR_histomx <- new.ms$AMR_histomx/100
new.ms$TCMR_histomx <- new.ms$TCMR_histomx/100
tab <- read.csv('~/Dropbox/PTG/transcriptomics/nanostring/kidney/refset/current/model_dev/model_eval/test_scores_all_annot.csv')
tab <- merge(new.ms, tab, all.y=TRUE, by="ID")
tab <- merge(new.att, tab, all.y=TRUE, by="ID")
nrow(tab)
head(tab)
colnames(tab)
colnames(tab)<-gsub(" ", "_", colnames(tab))
colnames(tab)
write.csv(tab, file='~/Dropbox/PTG/transcriptomics/nanostring/kidney/refset/current/model_dev/model_eval/test_scores_all_annot_histomx.csv', quote=F, row.names=F)
##---------
##PTG
dat <- tab[,c("Dx", "AMR_score", "dsa")]
#dat <- tab[,c("Dx", "AMR_histomx", "dsa")]
dat$Dx <- ifelse(dat$Dx=="amr" & is.na(dat$dsa), "amr_dsa_na",
ifelse(dat$Dx=="amr" & dat$dsa=="no", "amr_dsa0",
ifelse(dat$Dx=="amr" & dat$dsa=="yes", "amr_dsa1", dat$Dx)))
table(dat$Dx, useNA="ifany")
dat$dsa<-NULL
suppressWarnings({dat.m <- reshape2::melt(dat, id.vars="Dx")})
ggplot(dat.m, aes(x = forcats::fct_rev(Dx), y = value, fill=Dx)) + geom_boxplot() +
xlab("") + ylab("pAMR") +
#scale_fill_manual(values=c("navy",  "lightsteelblue", "orange")) +
theme(legend.position="none",
panel.border=element_rect(colour="gray", fill=NA, linewidth=1),
axis.text.y=element_text(size=16, color="black"),
axis.text.x=element_text(size=16, color="black", angle=90),
axis.title=element_text(size=16, color="black"),
panel.background=element_blank(),
panel.grid.minor=element_line(colour="gray"))
